exports.name="mv_pull";exports.version="0.1";exports.handleSignals=false;exports.group=C.INTERNAL_FUNCTION_GROUP;exports.sync=true;const{NestedPropertyAccessor}=C.expr;const cLogger=C.util.getLogger("func:mv_pull");const VALID_PATH_REGEX=/^(([a-z_$][\w$]*)|(__e\[(?<quote>['"])(?:(?!\k<quote>).)+?\k<quote>\])|(([a-z_$][\w$]*)(\.([a-z_$][\w$]*))+))$/i;let arrayNPA;let relativeKeyNPA;let relativeValueNPA;let targetBagNPA;let deleteOriginalArray;let relativeTargetNPACache;exports.init=e=>{const t=e?.conf;if(!t){throw new Error("Multi-value Expand not supported w/o configuration")}const{arrayPath:r,relativeKeyPath:a,relativeValuePath:o,targetBagPath:n,deleteOriginal:i}=t;if(!r||!a||!o){throw new Error(`Invalid function configuration for ${this.name}.`)}arrayNPA=new NestedPropertyAccessor(r,cLogger);relativeKeyNPA=new NestedPropertyAccessor(a,cLogger);relativeValueNPA=new NestedPropertyAccessor(o,cLogger);if(n){targetBagNPA=new NestedPropertyAccessor(n,cLogger)}relativeTargetNPACache=new Map;deleteOriginalArray=i??false};exports.unload=()=>{arrayNPA=relativeKeyNPA=relativeValueNPA=targetBagNPA=undefined;relativeTargetNPACache=undefined};exports.process=e=>{if(e===undefined)return e;const t=arrayNPA.get(e);if(!Array.isArray(t))return e;if(deleteOriginalArray){arrayNPA.set(e,undefined)}let r;let a;if(targetBagNPA){if(r=targetBagNPA.get(e)){if(typeof r!=="object"){return e}}else{targetBagNPA.deepSet(e,r={})}}else{r=e}for(const e of t){if(e==null||typeof e!=="object")continue;let t=relativeKeyNPA.get(e);if(!t)continue;t=String(t);const o=relativeValueNPA.get(e);if(o===undefined)continue;if(!(a=relativeTargetNPACache.get(t))){try{const e=VALID_PATH_REGEX.test(t)?t:`__e["${t}"]`;relativeTargetNPACache.set(t,a=new NestedPropertyAccessor(e,cLogger))}catch(e){cLogger.warn(`Invalid key name: ${t}`);continue}}a.deepSet(r,o)}return e};