exports.jobType="task-per-node";exports.name="clear_pq";const fs=require("fs");let outputId;let pqPath;const{util:{resolveEnvVars},internal:{PersistentQueue:{outputPath,orphanAssignments}}}=C;exports.initJob=async t=>{const{conf:e}=t.conf.executor;outputId=e.outputId;pqPath=e.pqPath};exports.jobSeedTask=async()=>({task:{outputId,pqPath}});exports.initTask=async t=>{};exports.jobOnError=async(t,e,s)=>{};exports.taskExecute=async(t,e)=>{const s=t.logger();s.info("task opts",{opts:e});let o=e.pqPath;if(!o){o=outputPath(e.outputId)}if(typeof o!=="string"||o.length===0)throw{message:"Misconfigured persistent queue path"};const r=resolveEnvVars(o);const a=await fs.promises.readdir(r);if(a.length>0){await Promise.all(a.map((async t=>{const o=`${r}/${t}/${e.outputId}`;s.debug("deleting path",{path:o});return fs.promises.rm(o,{recursive:true,force:true})})))}const n=await orphanAssignments();s.debug("orphans",{assignedPaths:n});if(n.length>0){await Promise.all(n.map((t=>{const o=`${t}/${e.outputId}`;s.debug("deleting orphan",{path:o});return fs.promises.rm(o,{recursive:true,force:true})})))}};