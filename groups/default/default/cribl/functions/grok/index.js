exports.name="Grok";exports.version="0.2";exports.group="Standard";exports.sync=true;const{GrokRule}=C;const{NestedPropertyAccessor}=C.expr;const dLogger=C.util.getLogger("func:grok");const DEFAULT_FIELD="_raw";let srcField;let rules=[];let idMappings;exports.init=e=>{const r=e.conf||{};srcField=new NestedPropertyAccessor(r.source||DEFAULT_FIELD);let s=[r.pattern];if(r.patternList){s=s.concat((r.patternList||[]).map((e=>e.pattern)))}idMappings=new Array(s.length);for(let e=0;e<s.length;e++){const{result:r,mappings:t}=supportNestedFields(s[e]);s[e]=r;idMappings[e]=t}return GrokRule.buildMany(s).then((e=>{rules=e;dLogger.debug("init",{rules,srcField,idMappings})}))};exports.process=e=>{const r=srcField.get(e);if(r==null)return e;const s=String(r);for(let r=0;r<rules.length;r++){const t=rules[r].exec(s);if(!t||!t.groups)continue;dLogger.debug("process",{execArray:t,groups:t.groups});const n=Object.keys(t.groups);for(let s=0;s<n.length;s++){const o=n[s];const p=t.groups[o];if(idMappings[r][o]){idMappings[r][o].deepSet(e,p)}else{e[o.replace(/\\W+/g,"_")]=p}}}return e};function supportNestedFields(e){const r={};const s=e?.replace(/%{([A-Z_]+):([^}]*\.[^}]*)}/g,((e,s,t)=>{const n="X"+Math.random().toString(36).substring(2,6);r[n]=new NestedPropertyAccessor(t);return`%{${s}:${n}}`}));return{result:s,mappings:r}}