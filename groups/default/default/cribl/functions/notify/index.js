exports.name="notify";exports.version="0.0.3";exports.disabled=false;exports.handleSignals=true;exports.group=C.INTERNAL_FUNCTION_GROUP;const DEFAULT_RESULTS_LIMIT=10;const DEFAULT_RESULTS_MAX_FIELDS=20;const DEFAULT_ATTACHMENT_RESULTS_LIMIT=5e4;let group,searchId,savedQueryId,notificationId,message,authToken,messagesEndpoint,searchUrl,logger,comparatorExpression,trigger="true",triggerCount=0,triggerExpression,resultsLimit=DEFAULT_RESULTS_LIMIT,resultsMaxFields=DEFAULT_RESULTS_MAX_FIELDS,attachmentResultsLimit=DEFAULT_ATTACHMENT_RESULTS_LIMIT,triggerCounter=0,triggerType="resultsCount",triggerComparator=">",targetConfig,targetType,notificationResults=[],notificationSent=false,signalCounter=0,utLogger=undefined,tenantId=undefined,emailAttachmentBuilder=null,includeResults=false,orderedFieldNames;const{RestVerb}=C.internal.HttpUtils;const{createRequest}=C.internal.kusto;const createNotification=(e,t,r,i,s,n,a,o,g)=>{const l={id:`SEARCH_NOTIFICATION_${t}_${e}`,severity:"info",_raw:r,title:`Scheduled search notification`,_time:e,now:e,group,searchId:s,savedQueryId:n,searchResultsUrl:a,notificationId:t,tenantId:o,message:r,__attachments:g?[g]:[],origin_metadata:{itemType:"link",id:s,type:"search",product:"search",groupId:""}};if(includeResults){l.resultSet=i}return l};const comparators=[">","<","===","!==",">=","<="];exports.init=async e=>{trigger="true";triggerCount=0;triggerExpression;triggerCounter=0;triggerType="resultsCount";triggerComparator=">";notificationResults=[];const t=e.conf;({searchId,message,savedQueryId,authToken,messagesEndpoint,searchUrl,utLogger,notificationId,tenantId,targetConfig,targetType,orderedFieldNames}=t);logger=utLogger??C.util.getLogger(`func:notify:${searchId}`);group=t.group??group;trigger=t.trigger??trigger;triggerExpression=new C.expr.Expression(trigger);resultsLimit=t.resultsLimit??DEFAULT_RESULTS_LIMIT;resultsMaxFields=t.resultsMaxFields??DEFAULT_RESULTS_MAX_FIELDS;attachmentResultsLimit=t.attachmentResultsLimit??DEFAULT_ATTACHMENT_RESULTS_LIMIT;triggerCount=t.triggerCount??triggerCount;triggerType=t.triggerType??triggerType;triggerComparator=t.triggerComparator??triggerComparator;includeResults=targetConfig?.conf?.includeResults??false;if(includeResults){switch(targetType){case"smtp":{const e=targetConfig?.conf?.attachmentType??"inline";switch(e){case"csv":case"json":{message=message.replace("{{resultSet}}","Results are attached.");const{attachmentDir:r}=t;emailAttachmentBuilder=new C.internal.emailAttachmentBuilder(r,e,notificationId);await emailAttachmentBuilder.init();break}default:message=message.replace("{{resultSet}}","Results appear in the table below.");break}break}case"sns":case"webhook":break;default:if(!message.includes("{{resultSet}}")){logger.info("Appending {{resultSet}} to message",{message});message=`${message.trimEnd()}\n\n{{resultSet}}`}break}}if(!comparators.includes(triggerComparator)){throw new Error(`Unknown comparator ${triggerComparator}`)}comparatorExpression=new C.expr.Expression(`triggerCounter ${triggerComparator} triggerCount`);logger.info("Initialized notify",{...t})};exports.process=async e=>{if(e.__signalEvent__==="final"&&!notificationSent){if(comparatorExpression.evalOn({triggerCounter,triggerCount})){await(emailAttachmentBuilder?.end());await sendNotification()}}if(e.__signalEvent__==="reset"){signalCounter++;if(signalCounter>1)logger.error("Signal event received in notify pipeline function, which cannot handle previews",{signalCounter})}if(e.__signalEvent__!=null||triggerType==="custom"&&!triggerExpression.evalOn(e))return e;triggerCounter++;if(notificationResults.length<resultsLimit){notificationResults.push(e.asObject())}if(emailAttachmentBuilder!=null&&notificationResults.length<attachmentResultsLimit&&!emailAttachmentBuilder.attachmentCapped){await emailAttachmentBuilder.write(e)}return e};async function sendNotification(){notificationSent=true;const e=new Date;const t=C.internal.searchNotificationUtils.truncateResults(notificationResults,orderedFieldNames,resultsLimit,resultsMaxFields);const{updatedMessage:r,templateContext:i}=C.internal.searchNotificationUtils.serializeResultsForTemplate(message,t,logger);const s=new C.internal.kusto.Template(r,false,logger);const n=s.render({...i,savedQueryId,searchId,searchResultsUrl:searchUrl,notificationId,timestamp:e.toISOString(),tenantId});s.dispose();const a=targetType==="webhook"?notificationResults:t;const o=createNotification(e.getTime(),notificationId,n,a,searchId,savedQueryId,searchUrl,tenantId,emailAttachmentBuilder?.getAttachmentDetails());await sendNotificationMessage(o)}async function sendNotificationMessage(e){const t=3;const r=1e3;const i=process.env.NODE_ENV!=="dev";for(let s=0;s<=t;s++){try{logger.debug("Sending message",{notiMessage:e});const t={url:messagesEndpoint,method:RestVerb.POST,payload:e,rejectUnauthorized:i};const r=await createRequest(t).addAuthToken(authToken).run();await r.readAsJSON();return}catch(e){logger.error("Error posting notification message",{error:e});logger.error("Sending attempt failed.");if(s<t){logger.info(`Retrying... Attempt ${s+1} of ${t}`);await new Promise((e=>setTimeout(e,r)))}else{throw new Error(`Failed to send bulletin message after ${t} attempts`)}}}}exports.unload=()=>{triggerExpression=undefined;notificationResults=undefined};