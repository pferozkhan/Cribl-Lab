exports.name="send";exports.version="0.0.2";exports.disabled=false;exports.handleSignals=true;exports.asyncTimeout=-1;exports.group=C.INTERNAL_FUNCTION_GROUP;const{randomBytes}=require("crypto");const SENDER_MODE="sender";let url,group="default",workspace="main",sendUrlTemplate,searchId,tee=false,flushMs=1e4,destination,lastFlush,logger,_eventsOut=0,_eventsDropped=0,_bytesOut=0,eventsReceived=0,suppressPreviews=false,receivedEvents=false,sendId=`${Date.now()}${randomBytes(4).toString("hex")}`,receivedFinal=false,mode=SENDER_MODE,accumulatedMetrics={eventsOut:0,eventsDropped:0,bytesOut:0};exports.init=async e=>{const t=e.conf;({url,searchId,sendUrlTemplate}=t);if(!searchId)throw new Error("searchId field is required");if(!sendUrlTemplate)throw new Error("sendUrlTemplate field is required");logger=C.util.getLogger(`sendFunction:${searchId}`);group=t.group??group;workspace=t.workspace??workspace;sendUrlTemplate=t.sendUrlTemplate??sendUrlTemplate;tee=t.tee??tee;flushMs=t.flushMs??flushMs;suppressPreviews=t.suppressPreviews;mode=t.mode??SENDER_MODE;if(mode==="metrics"&&tee){mode=SENDER_MODE}if(!url){url=templateStr(sendUrlTemplate,{workspace,group})}if(mode===SENDER_MODE){destination=await C.internal.kusto.send.createDestination({url,searchId})}_eventsOut=0;_bytesOut=0;_eventsDropped=0;eventsReceived=0;logger.info("Initialized send",{url,tee,searchId})};exports.process=async e=>{if(!tee&&e.__signalEvent__){switch(e.__signalEvent__){case"reset":case"complete_gen":return;case"timer":return flushStats(e);case"close":return flushStats(e);case"cancel":return e;case"final":{if(receivedFinal||e.__ctrlFields.includes("cancel"))return e;receivedFinal=true;try{await(destination?.close())}catch(e){logger.error("Error while closing destination",{error:e})}const t=createStatsEvent(e,true);logger.info("Final flushing stats & destination",{totalEventsOut:t.totalEventsOut,totalEventsDelivered:t.totalEventsDelivered,totalEventsDropped:t.totalEventsDropped,eventsReceived});t.status="Sending complete";return[t,e]}default:logger.warn("unhandled signal",{event:e});return e}}if(mode===SENDER_MODE){return await send(e,destination,tee)}else{accumulatedMetrics.bytesOut+=e.bytesOut??0;accumulatedMetrics.eventsDropped+=e.eventsDropped??0;accumulatedMetrics.eventsOut+=e.eventsOut??0;return flushStats(e)}};function getMetrics(){if(mode===SENDER_MODE){const{sentCount:e,bytesOut:t,numDropped:s}=destination?.reportStatus().metrics;return{bytesOut:t,eventsDropped:s,eventsOut:e}}return accumulatedMetrics}exports.unload=()=>{destination=undefined;url=undefined;receivedEvents=false;receivedFinal=false};async function send(e,t,s=false){eventsReceived++;if(s){if(e.__signalEvent__)return e;const s=e.__clone();await t.send(s);return e}await t.send(e);return flushStats(e)}function templateStr(e,t){return e.replace(/<\w+>/g,(e=>{const s=e.slice(1,-1);const n=t[s];if(!n){throw new Error(`Unknown replace token ${s}`)}return n}))}function createStatsEvent(e,t=false){const s=e.__clone(true,[]);const{eventsOut:n,bytesOut:r,eventsDropped:a}=getMetrics();const o=n-_eventsOut;const u=r-_bytesOut;const i=a-_eventsDropped;if(!t&&r===0&&n===0&&a===0)return undefined;const l=Object.assign(s,{status:"Sending",totalEventsDelivered:n-a,eventsOut:o,totalEventsOut:n,bytesOut:u,totalBytesOut:r,eventsDropped:i,totalEventsDropped:a,sendId,url,searchId,_time:Date.now()/1e3});_eventsOut=n;_bytesOut=r;_eventsDropped=a;return l}function flushStats(e){const t=[];if(!receivedEvents){receivedEvents=true;const s=e.__clone(true,[]);const n=Object.assign(s,{status:"Begin sending",searchId,sendId,url,group,workspace,_time:Date.now()/1e3});t.push(n)}const s=Date.now();if(!lastFlush)lastFlush=s;if(!suppressPreviews&&lastFlush+flushMs<s){logger.debug("timer flushing stats");const n=createStatsEvent(e);lastFlush=s;n&&t.push(n)}if(e.__signalEvent__){t.push(e)}return t.length?t:undefined}exports.UT_getDestination=()=>destination;exports.UT_getMode=()=>mode;